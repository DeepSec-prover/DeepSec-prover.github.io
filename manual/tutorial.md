---
  author:
    - name : Vincent Cheval
      webpage : https://members.loria.fr/vcheval
    - name : Steve Kremer
      webpage : https://members.loria.fr/SKremer
    - name : Itsaka Rakotonirina
      webpage : https://members.loria.fr/IRakotonirina

  title: DeepSec prover
  pagetitle: Manual - A small example
  mainpagetitle: Manual of DeepSec

  depth: ../

  navigation: true

  next_page: Grammar
  next_page_url: manual/grammar.html
  prev_page: Installation
  prev_page_url: manual/install.html
---

## Tutorial


### The Private Authentication Protocol

We will now explain protocol verification in **deepsec** through an example. As **deepsec** specializes in verifying equivalence properties, mainly used for modelling privacy preserving properties, we will use the Private Authentication Protocol (PAP) as our example [@AF-tcs04]. The protocol can be described in "Alice & Bob" notation as follows:

```
  A -> B: aenc( (Na,pk(skA)), pk(skB) )
  B -> A: aenc( (Na,Nb,pk(skB)), pk(skA) )     if B accepts requests from A
          aenc( Nb, pk(skB) )                  otherwise
```

Alice (A) makes a connection request to Bob (B). For this Alice sends the asymmetric encryption (`aenc`) of the pair `(Na,pk(skA)` with Bob's public key (`pk(skB)`).  Here `Na` is a fresh random nonce and `pk(skA)` is Alice's public key. Here, `pk(sk)` denotes the public key corresponding to the private key `sk`.  Bob may accept requests from Alice or not. The aim of the protocol is to conceal from outside observers whether Bob does accept connections from Alice or not. This is called _private_ authentication. If Alice is in the list of connections accepted by Bob, Bob replies with the message `aenc( (Na,Nb,pk(skB)), pk(skB) )`, i.e. the encryption of the tuple `(Na,Nb,pk(skB))` (where `Nb` is a fresh nonce generated by Bob) with Alice's public key `pk(skA)`. Otherwise, in order to hide the connection refusal, Bob sends a decoy message `aenc( Nb, pk(skB) )`.

The modelling of the PAP protocol in **deepsec** is available in the file

```
  Examples/trace_equivalence/Private_authentication/PrivateAuthentication-1session.dps
```

in the **deepsec** directory.


### Modelling messages in **deepsec**


As in other symbolic models, protocol messages are modelled as
*terms*. Therefore the first part of a **deepsec** file consists in
the necessary declarations. To model PAP we first declare a few constants.


```{.deepsec}
  free ca, cb, c.
  free ska, skb, skc [private].
```

Here, `ca, cb, c` are so-called *free* names: they model public
constants, that are known to the adversary. In PAP `ca, cb, c` will be
channel names, as we will see below. On the other hand we need to
declare *secret* keys. For this we use *private* names `ska, skb, skc`
that are declared with the additional attribute `[private]`.


Next, we need to declare function symbols to represent asymmetric encryption.

```{.deepsec}
  fun aenc/2.
  fun pk/1.
```
The function symbol `aenc` is declared to be of arity 2 using the
  notation `/2`. Public keys are of arity 1, as they are intended to
  take a secret key as argument.



> **Note:** public names _vs_ function symbols of arity 0
>
> It is possible to declare function symbols of arity 0, e.g. write
> `fun c/0`. This is equivalent to declaring a free name `free c`.



> **Note:** alternate modelling of secret keys using private function symbols
>
>In the modelling proposed above, we intend to compute the
>public key by applying the function `pk` to the secret key,
>e.g. `pk(ska)` would be A's public key. An alternate way of modelling
>can be to derive both the public and secret key from an identity: we
>could declare a _private_ function symbol `fun sk/1
>[private].`. Then, `pk(a)` and `sk(a)` represent A's public,
>respectively private, key. Declaring the function symbol `sk` as
>private implies that the attacker cannot apply this function symbol.


Currently, we have declared function symbols `aenc` and `pk`, but
nothing indicates that these functions represent asymmetric
encryption. We will use _rewrite rules_ to give meaning to these
function symbols.

```{.deepsec}
  reduc adec(aenc(x,pk(y)),y) -> x.
```

This rule indicates that an attacker can apply decryption `adec`; if
the keys match (which is required as we use the same variable `y` as
arguments in encryption and decryption) then the result of applying
decryption returns the plaintext `x`.


> **NOTE**: constructor-destructor algebras
>
> You may have noticed that we did not declare the `adec` symbol. This
>is because `adec` is a _destructor_, while declared function symbols
>are _constructors_. Destructors may actually not occur in protocol
>messages: if the above rewrite rule does not succeed the evaluation
>will _fail_. For example, the evaluation of the terms
>`adec(aenc(m,pk(ska)),skb)` and `adec(c,ska)` would both fail.



> **NOTE**: deterministic vs randomized encryption
>
> Example why sometimes randomized encryption is needed.



### Modelling protocols as processes

<span style="color:red">**To complete.**</span>


Alice's role

```{.deepsec}
  let processA(ca,ska,pkb) =
    new na;
    out(ca,aenc((na,pk(ska)),pkb));
    in(ca,x).
```

Bob's role

```{.deepsec}
  let processB(cb,skb,pka) =
    in(cb,yb);
    new nb;
    let (yna,=pka) = adec(yb,skb) in
      out(cb,aenc((yna,nb,pk(skb)),pka))
    else out(cb,aenc(nb,pk(skb))).
```

and the main process

```{.deepsec}
  let ProcessAB =
    out(c,pk(ska));
    out(c,pk(skb));
    out(c,pk(skc));
    (
      processA(ca,ska,pk(skb)) | processB(cb,skb,pk(ska))
    ).
```


### Verifying anonymity

Add a "second" main process

```{.deepsec}
  let ProcessCB =
    out(c,pk(ska));
    out(c,pk(skb));
    out(c,pk(skc));
    (
      processA(ca,skc,pk(skb)) | processB(cb,skb,pk(skc))
    ).
```

and add query

```{.deepsec}
  query trace_equiv(ProcessAB,ProcessCB).
```


To verify use command

```bash
  $ deepsec PrivateAuthentication-1session.dps
```

Deepsec says trace equivalent.


What happens when we remove the decoy message? Attack found.


### Distributing the computation

Big scenario increases computation time. Distribute the computation.


### The **deepsec** User Interface

Using the GUI in the example.
