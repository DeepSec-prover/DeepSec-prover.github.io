---
  author:
    - name : Vincent Cheval
      webpage : https://members.loria.fr/vcheval
    - name : Steve Kremer
      webpage : https://members.loria.fr/SKremer
    - name : Itsaka Rakotonirina
      webpage : https://members.loria.fr/IRakotonirina

  title: DeepSec prover
  pagetitle: Manual - A small example
  mainpagetitle: Manual of DeepSec

  depth: ../

  navigation: true

  next_page: Grammar
  next_page_url: manual/grammar.html
  prev_page: Installation
  prev_page_url: manual/install.html
---

## Tutorial


### The Private Authentication Protocol

We will now explain protocol verification in **deepsec** through an example. As **deepsec** specializes in verifying equivalence properties, mainly used for modelling privacy preserving properties, we will use the Private Authentication Protocol (PAP) as our example [@AF-tcs04]. The protocol can be described in "Alice & Bob" notation as follows:

```
  A -> B: aenc( (Na,pk(skA)), pk(skB) )
  B -> A: aenc( (Na,Nb,pk(skB)), pk(skA) )     if B accepts requests from A
          aenc( Nb, pk(skB) )                  otherwise
```

Alice (A) makes a connection request to Bob (B). For this Alice sends the asymmetric encryption (`aenc`) of the pair `(Na,pk(skA)` with Bob's public key (`pk(skB)`).  Here `Na` is a fresh random nonce and `pk(skA)` is Alice's public key. Here, `pk(sk)` denotes the public key corresponding to the private key `sk`.  Bob may accept requests from Alice or not. The aim of the protocol is to conceal from outside observers whether Bob does accept connections from Alice or not. This is called _private_ authentication. If Alice is in the list of connections accepted by Bob, Bob replies with the message `aenc( (Na,Nb,pk(skB)), pk(skB) )`, i.e. the encryption of the tuple `(Na,Nb,pk(skB))` (where `Nb` is a fresh nonce generated by Bob) with Alice's public key `pk(skA)`. Otherwise, in order to hide the connection refusal, Bob sends a decoy message `aenc( Nb, pk(skB) )`.

The modelling of the PAP protocol in **deepsec** is available in the
file

```bash
  PrivateAuthentication-1session.dps
```

located in 

```bash
  Examples/trace_equivalence/Private_authentication/
```

in the **deepsec** directory. We suggest that you move to that
directory and make sure that the **deepsec** executable is in your
path.


### Modelling messages in **deepsec**


As in other symbolic models, protocol messages are modelled as
*terms*. Therefore the first part of a **deepsec** file consists in
the necessary declarations. To model PAP we first declare a few constants.


```{.deepsec}
  free ca, cb, c.
  free ska, skb, skc [private].
```

Here, `ca, cb, c` are so-called *free* names: they model public
constants, that are known to the adversary. In PAP `ca, cb, c` will be
channel names, as we will see below. On the other hand we need to
declare *secret* keys. For this we use *private* names `ska, skb, skc`
that are declared with the additional attribute `[private]`.


Next, we need to declare function symbols to represent asymmetric encryption.

```{.deepsec}
  fun aenc/2.
  fun pk/1.
```
The function symbol `aenc` is declared to be of arity 2 using the
  notation `/2`. Public keys are of arity 1, as they are intended to
  take a secret key as argument.



> **Note:** public names _vs_ function symbols of arity 0
>
> It is possible to declare function symbols of arity 0, e.g. write
> `fun c/0`. This is equivalent to declaring a free name `free c`.



> **Note:** alternate modelling of secret keys using private function symbols
>
>In the modelling proposed above, we intend to compute the
>public key by applying the function `pk` to the secret key,
>e.g. `pk(ska)` would be A's public key. An alternate way of modelling
>can be to derive both the public and secret key from an identity: we
>could declare a _private_ function symbol `fun sk/1
>[private].`. Then, `pk(a)` and `sk(a)` represent A's public,
>respectively private, key. Declaring the function symbol `sk` as
>private implies that the attacker cannot apply this function symbol.


Currently, we have declared function symbols `aenc` and `pk`, but
nothing indicates that these functions represent asymmetric
encryption. We will use _rewrite rules_ to give meaning to these
function symbols.

```{.deepsec}
  reduc adec(aenc(x,pk(y)),y) -> x.
```

This rule indicates that an attacker can apply decryption `adec`; if
the keys match (which is required as we use the same variable `y` as
arguments in encryption and decryption) then the result of applying
decryption returns the plaintext `x`.


> **Note**: constructor-destructor algebras
>
> You may have noticed that we did not declare the `adec` symbol. This
>is because `adec` is a _destructor_, while declared function symbols
>are _constructors_. Destructors may actually not occur in protocol
>messages: if the above rewrite rule does not succeed the evaluation
>will _fail_. For example, the evaluation of the terms
>`adec(aenc(m,pk(ska)),skb)` and `adec(c,ska)` would both fail.



> **Note**: deterministic vs randomized encryption
>
>You may also note that we modelled encryption as a _deterministic_
>function. Of course, a secure encryption scheme needs to be
>randomized, but in this particular example this simplified version is
>sufficient. This means in particular that the attacker can
>distinguish messages `aenc(0,pk(ska))` and `aenc(1,pk(ska))` where
>`0` and `1` are constants as he could simply re-encrypt these
>constants (supposing he knows the public key). It is however easy to
>model asymmetric encryption by adding a random element, making `aenc`
>a ternary function.



### Modelling protocols as processes

We now need to model the behaviour of Alice and Bob. One can think of
a protocol as a distributed program. Each local program of this system
will be represented by a _process_.  We can model Alice's role by the
following process `processA`.

```{.deepsec}
  let processA(ca,ska,pkb) =
    new na;
    out(ca,aenc((na,pk(ska)),pkb));
    in(ca,x).
```

The process has 3 arguments: `ca` is the channel on which the process
communicates, `ska` is the secret key of the agent running this
process, and `pkb` is the public key of the agent to whom we want to
connect. First, the process generates a fresh random nonce using the command
`new na`. Next, it sends on channel `ca` the encryption of the pair `(na,pk(ska))`
encrypted with the recipient's public key `pkb`, as dictated by the
protocol. Finally, the process expects an input, modelled as
`in(ca,x)`. Normally, one would expect additional processing of the
input message, which we omit here for simplification.


> **Note** private names vs new names
>
>In the above example we use `new na` to create a fresh, private name
>na. This is again equivalent to declaring a free, private name, as we
>did for `ska, skb` and `skb`. However, the `new` construct is useful
>when a different, fresh name should be created in every instance of
>the process: if we execute several instances of `processA` a distinct
>fresh name `na` is created in each copy. 


Next, we model Bob's behaviour by the process `processB`.


```{.deepsec}
  let processB(cb,skb,pka) =
    in(cb,yb);
    new nb;
    let (yna,=pka) = adec(yb,skb) in
      out(cb,aenc((yna,nb,pk(skb)),pka))
    else out(cb,aenc(nb,pk(skb))).
```

This process introduces several new constructs that require
explanations. The first action of the process is to input a message on
channel `cb` through the instruction `in(cb,yb)`. As a consequence the
message that is received will be bound to the variable `yb`. While the
expected message is `aenc((na,pka)),pk(skb))` we need to keep in mind
that this message may actually be provided by the attacker and may be
an arbitrary message the attacker is able to forge. Therefore we need
to _parse_ the message and perform a number of tests. All of this is
done here in a condensed form using a `let` instruction. We first
decrypt (apply `adec`) the received message (referred to by the
variable `yb`) with the secret key `skb`. Note that if decryption
fails, we will enter the `else` branch of the `let` instruction. Next,
we check that the results is a pair: the first element of the pair is
bound to the variable `yna` and we check that the second variable of
the pair equals the public key `pka`, i.e., the public key of a person
we accept connections from. An expanded form could be written as
follows.

```{.deepsec}
   let yplain = adec(yb,skb) in
      let (yna,ypka) = yplain in
         if ypka = pka then
            out(cb,aenc((yna,nb,pk(skb)),pka))
         else out(cb,aenc(nb,pk(skb)));
      else out(cb,aenc(nb,pk(skb)));
   else out(cb,aenc(nb,pk(skb))).
```

This form is however rather lengthy and requires duplicating else
branches, which is why the above syntactic sugar is often convenient.

> **Note:** tuples in **deepsec**
>
> We have seen in the above example that we used notations `(a,b)` and
> `(a,b,c)` for tuples without explicitly declaring function symbols
> for pairs and triples. Actually, **deepsec** has built-in support
> for tuples. For each tuple of arity $n$ occurring in the processes
> **deepsec** will define the constructor `(_, ... ,_)` of arity n
> and corresponding destructors `reduc proj_i_n (x1, ... ,xi, ..., xn)
> = xi` (for all $1\leq i \leq n$). These destructors are used
> implicitly in the let instruction for projecting the elements of the
> tuple.



Finally, we put all the pieces together ia main process `ProcessAB`
modelling the entire system.

```{.deepsec}
  let ProcessAB =
    out(c,pk(ska));
    out(c,pk(skb));
    out(c,pk(skc));
    (
      processA(ca,ska,pk(skb)) | processB(cb,skb,pk(ska))
    ).
```
	
The system first outputs the public keys, so that they become known to
the attacker. Then the system indicates that processes `processA` and
`processB` are executed in parallel (each with its parameters). 

### Verifying private authentication

We are now interested in modelling anonymity. Anonymity is generally
modelled as the indistinguishability of two systems. We therefore
define a second system `ProcessCB`.

```{.deepsec}
  let ProcessCB =
    out(c,pk(ska));
    out(c,pk(skb));
    out(c,pk(skc));
    (
      processA(ca,skc,pk(skb)) | processB(cb,skb,pk(skc))
    ).
```

The difference with previous system `ProcessAB` is the parameter
`skc`, rather than `ska`, given to `processA` and `processB`. Hence,
`ProcessAB` models the situation where B is willing to receive
connections only from A, while in `ProcessCB`, B accepts connections
only from C. The goal of private authentication is to hide from whom
connections are accepted. Indistinguishability can be modelled by
trace equivalence. We can therefore query **deepsec** to check trace
equivalence between these two systems.


```{.deepsec}
  query trace_equiv(ProcessAB,ProcessCB).
```

To verify this query we use the command 

```bash
  $ deepsec PrivateAuthentication-1session.dps
```


**deepsec** will indeed confirm that this kind of anonymity is satisfied
by outputting (among some other messages) that

```bash
Result query 1: The two processes are not trace equivalent.
```

Looking at the protocol this is intuitively due to the decoy message
sent in the `else` branch of `processB`. What happens when we remove
the decoy message? For this we simply replace the else branch with
`else 0` (or omit it completely), see the file
`PrivateAuthentication-1session-attack.dps`. We can now run
**deepsec** on this modified file.

```bash
  $ deepsec PrivateAuthentication-1session-attack.dps
```

This time, **deepsec** will report an attack:

```bash
Result query 1: The two processes are not trace equivalent.
```

Indeed, when the attacker sends the message
`in(cb,aenc((n,pk(ska)),pk(skb)))` to B, only the first system will
send a reply.


### More complex scenarios and distributing the computation

Big scenario increases computation time. Distribute the computation.


### The **deepsec** User Interface

Using the GUI in the example.
