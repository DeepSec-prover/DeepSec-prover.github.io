---
  author:
    - name : Vincent Cheval
      webpage : https://members.loria.fr/vcheval
    - name : Steve Kremer
      webpage : https://members.loria.fr/SKremer
    - name : Itsaka Rakotonirina
      webpage : http://www.dptinfo.ens-cachan.fr/~irakoton

  title: DeepSec prover
  pagetitle: Manual - A small example
  mainpagetitle: Manual of DeepSec

  depth: ../

  navigation: true

  next_page: Grammar
  next_page_url: manual/grammar.html
  prev_page: Installation
  prev_page_url: manual/install.html
---

## Tutorial


### The Private Authentication Protocol

We will now explain protocol verification in **deepsec** through an example. As **deepsec** specializes in verifying equivalence properties, mainly used for modelling privacy preserving properties, we will use the Private Authentication Protocol (PAP) as our example [@AF-tcs04]. The protocol can be described in "Alice & Bob" notation as follows:

```
  A -> B: aenc( (Na,pk(skA)), pk(skB) )
  B -> A: aenc( (Na,Nb,pk(skB)), pk(skA) )     if B accepts requests from A
          aenc( Nb, pk(skB) )                  otherwise
```

Alice (A) makes a connection request to Bob (B). For this Alice sends the asymmetric encryption (`aenc`) of the pair `(Na,pk(skA)` with Bob's public key (`pk(skB)`).  Here `Na` is a fresh random nonce and `pk(skA)` is Alice's public key. Here, `pk(sk)` denotes the public key corresponding to the private key `sk`.  Bob may accept requests from Alice or not. The aim of the protocol is to conceal from outside observers whether Bob does accept connections from Alice or not. This is called _private_ authentication. If Alice is in the list of connections accepted by Bob, Bob replies with the message `aenc( (Na,Nb,pk(skB)), pk(skB) )`, i.e. the encryption of the tuple `(Na,Nb,pk(skB))` (where `Nb` is a fresh nonce generated by Bob) with Alice's public key `pk(skA)`. Otherwise, in order to hide the connection refusal, Bob sends a decoy message `aenc( Nb, pk(skB) )`.

The modelling of the PAP protocol in **deepsec** is available in the file

```
Examples/trace_equivalence/Private_authentication/PrivateAuthentication-1session.dps
```

in the **deepsec** directory.


### Modelling messages in **deepsec**


<span style="color:red">**To complete.**</span>

Names, constants, etc.

```{.deepsec}
  free ca, cb, c.
  free ska, skb, skc [private].
```

Declaring function symbols

```{.deepsec}
  fun aenc/2.
  fun pk/1.
```

Rewrite rules

```{.deepsec}
  reduc adec(aenc(x,pk(y)),y) -> x.
```

> **NOTE**: constructor-destructor
>
> Explain difference between equations and reduc!



> **NOTE**: deterministic vs randomized encryption
>
> Example why sometimes randomized encryption is needed.



### Modelling protocols as processes

<span style="color:red">**To complete.**</span>


Alice's role

```{.deepsec}
  let processA(ca,ska,pkb) =
    new na;
    out(ca,aenc((na,pk(ska)),pkb));
    in(ca,x).
```

Bob's role

```{.deepsec}
  let processB(cb,skb,pka) =
    in(cb,yb);
    new nb;
    let (yna,=pka) = adec(yb,skb) in
      out(cb,aenc((yna,nb,pk(skb)),pka))
    else out(cb,aenc(nb,pk(skb))).
```

and the main process

```{.deepsec}
  let ProcessAB =
    out(c,pk(ska));
    out(c,pk(skb));
    out(c,pk(skc));
    (
      processA(ca,ska,pk(skb)) | processB(cb,skb,pk(ska))
    ).
```


### Verifying anonymity

Add a "second" main process

```{.deepsec}
  let ProcessCB =
    out(c,pk(ska));
    out(c,pk(skb));
    out(c,pk(skc));
    (
      processA(ca,skc,pk(skb)) | processB(cb,skb,pk(skc))
    ).
```

and add query

```{.deepsec}
  query trace_equiv(ProcessAB,ProcessCB).
```


To verify use command

```bash
  $ deepsec PrivateAuthentication-1session.dps
```

Deepsec says trace equivalent.


What happens when we remove the decoy message? Attack found.


### Distributing the computation

Big scenario increases computation time. Distribute the computation.


### The **deepsec** User Interface

Using the GUI in the example.
